{
  "language": "Solidity",
  "sources": {
    "@carrot-swap/bridge-evm/contracts/CarrotBridgeConnector.base.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\nimport \"./libraries/Pausable.sol\";\n\nimport \"./interfaces/ConnectorErrors.sol\";\nimport \"./interfaces/CarrotBridgeInterfaces.sol\";\n\n/**\n * @dev Main abstraction of CarrotBridgeConnector.\n * This contract manages interactions between TSS and different chains.\n * There's an instance of this contract on each chain supported by CarrotBridge.\n */\ncontract CarrotBridgeConnectorBase is ConnectorErrors, Pausable {\n    /**\n     * @dev Multisig contract to pause incoming transactions.\n     * The responsibility of pausing outgoing transactions is left to the protocol for more flexibility.\n     */\n    address public pauserAddress;\n\n    /**\n     * @dev Collectively held by CarrotBridge validators.\n     */\n    address public tssAddress;\n\n    /**\n     * @dev This address will start pointing to a multisig contract, then it will become the TSS address itself.\n     */\n    address public tssAddressUpdater;\n\n    event BridgeMessageSent(\n        address sourceTxOriginAddress,\n        address indexed bridgeTxSenderAddress,\n        uint256 indexed destinationChainId,\n        address destinationAddress,\n        uint256 destinationGasLimit,\n        bytes message,\n        bytes bridgeParams\n    );\n\n    event BridgeMessageReceived(\n        address bridgeTxSenderAddress,\n        uint256 indexed sourceChainId,\n        address indexed destinationAddress,\n        bytes message,\n        bytes32 indexed internalSendHash\n    );\n\n    event BridgeMessageReverted(\n        address bridgeTxSenderAddress,\n        uint256 sourceChainId,\n        uint256 indexed destinationChainId,\n        address destinationAddress,\n        bytes message,\n        bytes32 indexed internalSendHash\n    );\n\n    event TSSAddressUpdated(address callerAddress, address newTssAddress);\n\n    event TSSAddressUpdaterUpdated(address callerAddress, address newTssUpdaterAddress);\n\n    event PauserAddressUpdated(address callerAddress, address newTssAddress);\n\n    /**\n     * @dev Constructor requires initial addresses.\n     */\n    constructor(address tssAddress_, address tssAddressUpdater_, address pauserAddress_) {\n        if (\n            tssAddress_ == address(0) ||\n            tssAddressUpdater_ == address(0) ||\n            pauserAddress_ == address(0)\n        ) {\n            revert CommonErrors.InvalidAddress();\n        }\n\n        tssAddress = tssAddress_;\n        tssAddressUpdater = tssAddressUpdater_;\n        pauserAddress = pauserAddress_;\n    }\n\n    /**\n     * @dev Modifier to restrict actions to pauser address.\n     */\n    modifier onlyPauser() {\n        if (msg.sender != pauserAddress) revert CallerIsNotPauser(msg.sender);\n        _;\n    }\n\n    /**\n     * @dev Modifier to restrict actions to TSS address.\n     */\n    modifier onlyTssAddress() {\n        if (msg.sender != tssAddress) revert CallerIsNotTss(msg.sender);\n        _;\n    }\n\n    /**\n     * @dev Modifier to restrict actions to TSS updater address.\n     */\n    modifier onlyTssUpdater() {\n        if (msg.sender != tssAddressUpdater) revert CallerIsNotTssUpdater(msg.sender);\n        _;\n    }\n\n    /**\n     * @dev Update the pauser address. The only address allowed to do that is the current pauser.\n     */\n    function updatePauserAddress(address pauserAddress_) external onlyPauser {\n        if (pauserAddress_ == address(0)) revert CommonErrors.InvalidAddress();\n\n        pauserAddress = pauserAddress_;\n\n        emit PauserAddressUpdated(msg.sender, pauserAddress_);\n    }\n\n    /**\n     * @dev Update the TSS address. The address can be updated by the TSS updater or the TSS address itself.\n     */\n    function updateTssAddress(address tssAddress_) external {\n        if (msg.sender != tssAddress && msg.sender != tssAddressUpdater)\n            revert CallerIsNotTssOrUpdater(msg.sender);\n        if (tssAddress_ == address(0)) revert CommonErrors.InvalidAddress();\n\n        tssAddress = tssAddress_;\n\n        emit TSSAddressUpdated(msg.sender, tssAddress_);\n    }\n\n    /**\n     * @dev Changes the ownership of tssAddressUpdater to be the one held by the CarrotBridge TSS Signer nodes.\n     */\n    function renounceTssAddressUpdater() external onlyTssUpdater {\n        if (tssAddress == address(0)) revert CommonErrors.InvalidAddress();\n\n        tssAddressUpdater = tssAddress;\n        emit TSSAddressUpdaterUpdated(msg.sender, tssAddressUpdater);\n    }\n\n    /**\n     * @dev Pause the input (send) transactions.\n     */\n\n    function pause() external onlyPauser {\n        _pause();\n    }\n\n    /**\n     * @dev Unpause the contract to allow transactions again.\n     */\n\n    function unpause() external onlyPauser {\n        _unpause();\n    }\n\n    /**\n     * @dev Entrypoint to send data and value through CarrotBridge.\n     */\n    function send(CarrotBridgeInterfaces.SendInput calldata input) external virtual {}\n\n    /**\n     * @dev Handler to receive data from other chain.\n     * This method can be called only by TSS. Access validation is in implementation.\n     */\n    function onReceive(\n        address bridgeTxSenderAddress,\n        uint256 sourceChainId,\n        address destinationAddress,\n        bytes calldata message,\n        bytes32 internalSendHash\n    ) external virtual {}\n\n    /**\n     * @dev Handler to receive errors from other chain.\n     * This method can be called only by TSS. Access validation is in implementation.\n     */\n    function onRevert(\n        address bridgeTxSenderAddress,\n        uint256 sourceChainId,\n        address destinationAddress,\n        uint256 destinationChainId,\n        bytes calldata message,\n        bytes32 internalSendHash\n    ) external virtual {}\n}\n"
    },
    "@carrot-swap/bridge-evm/contracts/CarrotBridgeInteractor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\nimport \"./libraries/Ownable.sol\";\nimport \"./interfaces/CarrotBridgeInterfaces.sol\";\nimport \"./interfaces/CarrotBridgeInteractorErrors.sol\";\nimport \"./CarrotBridgeConnector.base.sol\";\n\nabstract contract CarrotBridgeInteractor is Ownable, CarrotBridgeInteractorErrors {\n    bytes32 constant ZERO_BYTES = keccak256(new bytes(0));\n    uint256 internal immutable currentChainId;\n    CarrotBridgeConnectorBase public immutable connector;\n\n    /**\n     * @dev Maps a chain id to its corresponding address of the MultiChainSwap contract\n     * The address is expressed in bytes to allow non-EVM chains\n     * This mapping is useful, mainly, for two reasons:\n     *  - Given a chain id, the contract is able to route a transaction to its corresponding address\n     *  - To check that the messages (onBridgeMessage, onBridgeRevert) come from a trusted source\n     */\n    mapping(uint256 => address) public interactorsByChainId;\n\n    modifier isValidMessageCall(CarrotBridgeInterfaces.BridgeMessage calldata bridgeMessage) {\n        _isValidCaller();\n        if ((bridgeMessage.txSenderAddress) != (interactorsByChainId[bridgeMessage.sourceChainId]))\n            revert InvalidBridgeMessageCall();\n        _;\n    }\n\n    modifier isValidRevertCall(CarrotBridgeInterfaces.BridgeRevert calldata bridgeRevert) {\n        _isValidCaller();\n        if (bridgeRevert.txSenderAddress != address(this)) revert InvalidBridgeRevertCall();\n        if (bridgeRevert.sourceChainId != currentChainId) revert InvalidBridgeRevertCall();\n        _;\n    }\n\n    constructor(address carrotBridgeConnectorAddress) {\n        if (carrotBridgeConnectorAddress == address(0)) revert CommonErrors.InvalidAddress();\n        currentChainId = block.chainid;\n        connector = CarrotBridgeConnectorBase(carrotBridgeConnectorAddress);\n    }\n\n    function _isValidCaller() private view {\n        if (msg.sender != address(connector)) revert InvalidCaller(msg.sender);\n    }\n\n    /**\n     * @dev Useful for contracts that inherit from this one\n     */\n    function _isValidChainId(uint256 chainId) internal view returns (bool) {\n        return ((interactorsByChainId[chainId]) != address(0));\n    }\n\n    function setInteractorByChainId(\n        uint256 destinationChainId,\n        address contractAddress\n    ) external onlyOwner {\n        interactorsByChainId[destinationChainId] = contractAddress;\n    }\n}\n"
    },
    "@carrot-swap/bridge-evm/contracts/interfaces/CarrotBridgeInteractorErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\n/**\n * @dev Interface with Bridge Interactor errors\n */\ninterface CarrotBridgeInteractorErrors {\n    // @dev Thrown when try to send a message or tokens to a non whitelisted chain\n    error InvalidDestinationChainId();\n\n    // @dev Thrown when the caller is invalid. e.g.: if onBridgeMessage or onBridgeRevert are not called by Connector\n    error InvalidCaller(address caller);\n\n    // @dev Thrown when message on onBridgeMessage has the wrong format\n    error InvalidBridgeMessageCall();\n\n    // @dev Thrown when message on onBridgeRevert has the wrong format\n    error InvalidBridgeRevertCall();\n}\n"
    },
    "@carrot-swap/bridge-evm/contracts/interfaces/CarrotBridgeInterfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\ninterface CarrotBridgeInterfaces {\n    /**\n     * @dev Use SendInput to interact with the Connector: connector.send(SendInput)\n     */\n    struct SendInput {\n        /// @dev Chain id of the destination chain.\n        uint256 destinationChainId;\n        /// @dev Address receiving the message on the destination chain (expressed in bytes since it can be non-EVM)\n        address destinationAddress;\n        /// @dev Gas limit for the destination chain's transaction\n        uint256 destinationGasLimit;\n        /// @dev An encoded, arbitrary message to be parsed by the destination contract\n        bytes message;\n        /// @dev Optional parameters for the CarrotBridge protocol\n        bytes bridgeParams;\n    }\n\n    /**\n     * @dev Our Connector calls onBridgeMessage with this struct as argument\n     */\n    struct BridgeMessage {\n        address txSenderAddress;\n        uint256 sourceChainId;\n        address destinationAddress;\n        bytes message;\n    }\n\n    /**\n     * @dev Our Connector calls onBridgeRevert with this struct as argument\n     */\n    struct BridgeRevert {\n        address txSenderAddress;\n        uint256 sourceChainId;\n        address destinationAddress;\n        uint256 destinationChainId;\n        bytes message;\n    }\n}\n\ninterface CarrotBridgeConnector {\n    /**\n     * @dev Sending value and data cross-chain is as easy as calling connector.send(SendInput)\n     */\n    function send(CarrotBridgeInterfaces.SendInput calldata input) external;\n}\n\ninterface CarrotBridgeReceiver {\n    /**\n     * @dev onBridgeMessage is called when a cross-chain message reaches a contract\n     */\n    function onBridgeMessage(CarrotBridgeInterfaces.BridgeMessage calldata bridgeMessage) external;\n\n    /**\n     * @dev onBridgeRevert is called when a cross-chain message reverts.\n     * It's useful to rollback to the original state\n     */\n    function onBridgeRevert(CarrotBridgeInterfaces.BridgeRevert calldata bridgeRevert) external;\n}\n\ninterface CommonErrors {\n    error InvalidAddress();\n}\n"
    },
    "@carrot-swap/bridge-evm/contracts/interfaces/ConnectorErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\n/**\n * @dev Interface with connector custom errors\n */\ninterface ConnectorErrors {\n    // @dev Thrown when caller is not the address defined as paused address\n    error CallerIsNotPauser(address caller);\n\n    // @dev Thrown when caller is not the address defined as TSS address\n    error CallerIsNotTss(address caller);\n\n    // @dev Thrown when caller is not the address defined as TSS Updater address\n    error CallerIsNotTssUpdater(address caller);\n\n    // @dev Thrown when caller is not the address defined as TSS or TSS Updater address\n    error CallerIsNotTssOrUpdater(address caller);\n\n    // @dev Thrown when maxSupply will be exceed if minting will proceed\n    error ExceedsMaxSupply(uint256 maxSupply);\n}\n"
    },
    "@carrot-swap/bridge-evm/contracts/libraries/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity >=0.8.7;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@carrot-swap/bridge-evm/contracts/libraries/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity >=0.8.7;\n\nimport {Context} from \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@carrot-swap/bridge-evm/contracts/libraries/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity >=0.8.7;\n\nimport {Context} from \"./Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\nimport \"./Mintable.sol\";\n\ninterface IERC20 is Mintable {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transfer(address to, uint value) external returns (bool);\n\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"
    },
    "contracts/interfaces/Mintable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface Mintable {\n    function mint(address to, uint amount) external;\n\n    function burn(uint amount) external;\n}\n"
    },
    "contracts/TokenBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\nimport \"@carrot-swap/bridge-evm/contracts/CarrotBridgeInteractor.sol\";\nimport \"@carrot-swap/bridge-evm/contracts/interfaces/CarrotBridgeInterfaces.sol\";\nimport \"./interfaces/IERC20.sol\";\n\ncontract TokenBridge is CarrotBridgeInteractor, CarrotBridgeReceiver {\n    mapping(uint256 => address) tokenMap;\n    mapping(uint256 => address) allowedSender;\n\n    constructor(\n        address carrotBridgeConnectorAddress\n    ) public CarrotBridgeInteractor(carrotBridgeConnectorAddress) Ownable(msg.sender) {}\n\n    function onBridgeMessage(\n        CarrotBridgeInterfaces.BridgeMessage calldata message\n    ) external override isValidMessageCall(message) {\n        (uint256 tokenId, address to, uint256 amount) = abi.decode(\n            message.message,\n            (uint256, address, uint256)\n        );\n        mint(message.sourceChainId, message.txSenderAddress, tokenId, to, amount);\n    }\n\n    function onBridgeRevert(\n        CarrotBridgeInterfaces.BridgeRevert calldata bridgeRevert\n    ) external override isValidRevertCall(bridgeRevert) {}\n\n    function mint(\n        uint256 sourceChainId,\n        address txSenderAddress,\n        uint256 tokenId,\n        address to,\n        uint256 amount\n    ) public onlyTssOrConnector {\n        require((allowedSender[sourceChainId]) != txSenderAddress, \"Not allowed\");\n        require(tokenId == currentChainId || tokenMap[tokenId] != address(0), \"Not valid chain id\");\n        if (tokenId == currentChainId) {\n            payable(to).transfer(amount);\n        } else {\n            IERC20(tokenMap[tokenId]).mint(to, amount);\n        }\n        emit Minted(tokenId, to, amount);\n    }\n\n    function sendETH(address toAddress, uint256 chainId) external payable {\n        require(interactorsByChainId[chainId] != address(0), \"Not valid chain id\");\n        emit Burned(currentChainId, msg.sender, msg.value);\n        connector.send(\n            CarrotBridgeInterfaces.SendInput({\n                destinationChainId: chainId,\n                destinationAddress: interactorsByChainId[chainId],\n                destinationGasLimit: 0,\n                message: abi.encode(currentChainId, toAddress, msg.value),\n                bridgeParams: abi.encode(\"\")\n            })\n        );\n    }\n\n    function sendERC20(\n        address toAddress,\n        uint256 chainId,\n        uint256 tokenId,\n        uint256 amount\n    ) external {\n        require(tokenMap[tokenId] != address(0), \"Not valid chain id\");\n        require(interactorsByChainId[chainId] != address(0), \"Not valid chain id\");\n        IERC20(tokenMap[tokenId]).transferFrom(msg.sender, address(this), amount);\n        IERC20(tokenMap[tokenId]).burn(amount);\n        emit Burned(tokenId, msg.sender, amount);\n        connector.send(\n            CarrotBridgeInterfaces.SendInput({\n                destinationChainId: chainId,\n                destinationAddress: interactorsByChainId[chainId],\n                destinationGasLimit: 0,\n                message: abi.encode(tokenId, toAddress, amount),\n                bridgeParams: abi.encode(\"\")\n            })\n        );\n    }\n\n    function setToken(uint256 tokenId, address tokenAddress) external onlyOwner {\n        tokenMap[tokenId] = tokenAddress;\n    }\n\n    event Minted(uint256 tokenId, address to, uint256 amount);\n    event Burned(uint256 tokenId, address from, uint256 amount);\n\n    modifier onlyTssOrConnector() {\n        if (address(connector) != _msgSender() && connector.tssAddress() != _msgSender()) {\n            revert(\"Permission Denied\");\n        }\n        _;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}